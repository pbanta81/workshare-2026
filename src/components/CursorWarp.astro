---
/**
 * Interactive WebGL Shader Background
 * 
 * Features:
 * - Hexagonal dot grid with hover/repel effects
 * - Click ripple animation
 * - Color sampling from header image
 * - Soft-edged anti-aliased dots
 * 
 * Keyboard: Shift+D to hide/show control panel
 */
---

<canvas id="warp-canvas"></canvas>

<!-- Control Panel -->
<div id="shader-controls" class="hidden">
  <div class="control-header">
    <span>Shader Controls</span>
    <div class="control-header-buttons">
      <button id="reset-controls" title="Reset to defaults">↺</button>
      <button id="toggle-controls">−</button>
    </div>
  </div>
  <div class="control-body">
    <div class="control-section" data-section="hover">
      <h4><span>Hover Effect</span><button class="section-toggle">−</button></h4>
      <div class="section-content">
        <label>
          <span class="label-text">Radius:</span>
          <input type="number" id="hoverRadiusVal" value="300" min="50" max="400">
          <input type="range" id="hoverRadius" min="50" max="400" value="300">
        </label>
        <label>
          <span class="label-text">Fade Distance:</span>
          <input type="number" id="hoverFadeVal" value="100" min="20" max="300">
          <input type="range" id="hoverFade" min="20" max="300" value="100">
        </label>
        <label>
          <span class="label-text">Max Scale:</span>
          <input type="number" id="hoverMaxScaleVal" value="16" min="2" max="16">
          <input type="range" id="hoverMaxScale" min="2" max="16" value="16">
        </label>
        <label>
          <span class="label-text">Repel Strength:</span>
          <input type="number" id="repelStrengthVal" value="23" min="0" max="30">
          <input type="range" id="repelStrength" min="0" max="30" value="23">
        </label>
        <label>
          <span class="label-text">Color Intensity:</span>
          <input type="number" id="colorIntensityVal" value="0.2" min="0" max="1" step="0.05">
          <input type="range" id="colorIntensity" min="0" max="1" value="0.2" step="0.05">
        </label>
        <label>
          <span class="label-text">Gumminess:</span>
          <input type="number" id="gumminessVal" value="0.08" min="0.02" max="0.3" step="0.01">
          <input type="range" id="gumminess" min="0.02" max="0.3" value="0.08" step="0.01">
        </label>
      </div>
    </div>
    <div class="control-section" data-section="ripple">
      <h4><span>Click Ripple</span><button class="section-toggle">−</button></h4>
      <div class="section-content">
        <label>
          <span class="label-text">Speed:</span>
          <input type="number" id="rippleSpeedVal" value="1800" min="200" max="2000">
          <input type="range" id="rippleSpeed" min="200" max="2000" value="1800">
        </label>
        <label>
          <span class="label-text">Width:</span>
          <input type="number" id="rippleWidthVal" value="366" min="20" max="400">
          <input type="range" id="rippleWidth" min="20" max="400" value="366">
        </label>
        <label>
          <span class="label-text">Duration:</span>
          <input type="number" id="rippleDurationVal" value="0.5" min="0.3" max="4" step="0.1">
          <input type="range" id="rippleDuration" min="0.3" max="4" value="0.5" step="0.1">
        </label>
        <label>
          <span class="label-text">Color Intensity:</span>
          <input type="number" id="rippleColorIntensityVal" value="0" min="0" max="1" step="0.05">
          <input type="range" id="rippleColorIntensity" min="0" max="1" value="0" step="0.05">
        </label>
      </div>
    </div>
    <div class="control-section" data-section="colorpickup">
      <h4><span>Image Color Pickup</span><button class="section-toggle">−</button></h4>
      <div class="section-content">
        <label>
          <span class="label-text">Range:</span>
          <input type="number" id="colorPickupRangeVal" value="400" min="50" max="800">
          <input type="range" id="colorPickupRange" min="50" max="800" value="400">
        </label>
        <label>
          <span class="label-text">Vibrancy:</span>
          <input type="number" id="colorVibrancyVal" value="0.8" min="0" max="1" step="0.05">
          <input type="range" id="colorVibrancy" min="0" max="1" value="0.8" step="0.05">
        </label>
        <label>
          <span class="label-text">Softness:</span>
          <input type="number" id="colorSoftnessVal" value="20" min="5" max="100">
          <input type="range" id="colorSoftness" min="5" max="100" value="20">
        </label>
      </div>
    </div>
    <div class="control-section" data-section="glitch">
      <h4><span>Heading Glitch</span><button class="section-toggle">−</button></h4>
      <div class="section-content">
        <label>
          <span class="label-text">Duration:</span>
          <input type="number" id="glitchDurationVal" value="380" min="50" max="500" step="10">
          <input type="range" id="glitchDuration" min="50" max="500" value="380" step="10">
        </label>
        <label>
          <span class="label-text">Intensity:</span>
          <input type="number" id="glitchIntensityVal" value="20" min="2" max="40">
          <input type="range" id="glitchIntensity" min="2" max="40" value="20">
        </label>
      </div>
    </div>
    <div class="control-section" data-section="welcome-glitch">
      <h4><span>Welcome Glitch</span><button class="section-toggle">−</button></h4>
      <div class="section-content">
        <label>
          <span class="label-text">Duration:</span>
          <input type="number" id="welcomeGlitchDurationVal" value="350" min="100" max="800" step="10">
          <input type="range" id="welcomeGlitchDuration" min="100" max="800" value="350" step="10">
        </label>
        <label>
          <span class="label-text">Intensity:</span>
          <input type="number" id="welcomeGlitchIntensityVal" value="18" min="5" max="50">
          <input type="range" id="welcomeGlitchIntensity" min="5" max="50" value="18">
        </label>
      </div>
    </div>
  </div>
</div>

<style>
  #warp-canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -1;
  }
  
  #shader-controls {
    position: fixed;
    top: 20px;
    right: 20px;
    background: rgba(13, 14, 17, 0.95);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 12px;
    font-family: 'DM Sans', system-ui, sans-serif;
    font-size: 12px;
    color: #a1a1aa;
    z-index: 9999;
    min-width: 220px;
    backdrop-filter: blur(10px);
  }
  
  #shader-controls.hidden {
    display: none;
  }
  
  .control-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 16px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    color: #e4e4e7;
    font-weight: 500;
  }
  
  .control-header-buttons {
    display: flex;
    gap: 8px;
  }
  
  .control-header button {
    background: none;
    border: none;
    color: #a1a1aa;
    cursor: pointer;
    font-size: 18px;
    line-height: 1;
    padding: 0 4px;
  }
  
  .control-header button:hover {
    color: #22d3ee;
  }
  
  .control-body {
    padding: 12px 16px;
  }
  
  .control-body.collapsed {
    display: none;
  }
  
  /* Hide header border when body is collapsed */
  #shader-controls:has(.control-body.collapsed) .control-header {
    border-bottom: none;
  }
  
  .control-section {
    margin-bottom: 12px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    padding-bottom: 12px;
  }
  
  .control-section:last-child {
    margin-bottom: 0;
    border-bottom: none;
    padding-bottom: 0;
  }
  
  .control-section h4 {
    margin: 0 0 8px 0;
    color: #22d3ee;
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    cursor: pointer;
  }
  
  .control-section h4:hover {
    color: #67e8f9;
  }
  
  .section-toggle {
    background: none;
    border: none;
    color: #a1a1aa;
    font-size: 14px;
    cursor: pointer;
    padding: 0 4px;
    line-height: 1;
  }
  
  .section-toggle:hover {
    color: #22d3ee;
  }
  
  .control-section.collapsed .section-content {
    display: none;
  }
  
  .control-section.collapsed h4 {
    margin-bottom: 0;
  }
  
  label {
    display: block;
    margin-bottom: 10px;
  }
  
  .label-text {
    display: inline-block;
    min-width: 100px;
  }
  
  input[type="number"] {
    width: 60px;
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 4px;
    color: #e4e4e7;
    padding: 2px 6px;
    font-size: 11px;
    font-family: inherit;
    text-align: right;
    float: right;
  }
  
  input[type="number"]:focus {
    outline: none;
    border-color: #22d3ee;
    background: rgba(255, 255, 255, 0.15);
  }
  
  input[type="number"]::-webkit-inner-spin-button,
  input[type="number"]::-webkit-outer-spin-button {
    opacity: 0.5;
  }
  
  input[type="range"] {
    width: 100%;
    margin-top: 6px;
    accent-color: #22d3ee;
    clear: both;
  }
</style>

<script>
  const canvas = document.getElementById('warp-canvas') as HTMLCanvasElement;
  const gl = canvas.getContext('webgl', { alpha: false });
  
  // Default values (for reset functionality)
  const defaults = {
    hoverRadius: 300,
    hoverFade: 100,
    hoverMaxScale: 16,
    repelStrength: 23,
    colorIntensity: 0.2,
    gumminess: 0.08,
    rippleSpeed: 1800,
    rippleWidth: 366,
    rippleDuration: 0.5,
    rippleColorIntensity: 0,
    baseDotSize: 3,      // Fixed (no UI control)
    dotRoundness: 0,     // Fixed (no UI control)
    colorPickupRange: 400,
    colorVibrancy: 0.8,
    colorSoftness: 20,
    glitchDuration: 380,
    glitchIntensity: 20,
    welcomeGlitchDuration: 350,
    welcomeGlitchIntensity: 18,
  };
  
  // Control panel state (starts with defaults)
  const params = { ...defaults };
  
  // Setup control panel
  function setupControls() {
    const controlPanel = document.getElementById('shader-controls')!;
    const toggle = document.getElementById('toggle-controls')!;
    const body = document.querySelector('.control-body')!;
    
    // Keyboard shortcut: Shift+D to toggle control panel
    document.addEventListener('keydown', (e) => {
      if (e.shiftKey && e.key === 'D') {
        e.preventDefault();
        controlPanel.classList.toggle('hidden');
      }
    });
    
    toggle.addEventListener('click', () => {
      body.classList.toggle('collapsed');
      toggle.textContent = body.classList.contains('collapsed') ? '+' : '−';
    });
    
    // Section collapse toggles
    document.querySelectorAll('.control-section h4').forEach(header => {
      header.addEventListener('click', () => {
        const section = header.closest('.control-section')!;
        section.classList.toggle('collapsed');
        const toggleBtn = header.querySelector('.section-toggle')!;
        toggleBtn.textContent = section.classList.contains('collapsed') ? '+' : '−';
      });
    });
    
    // Glitch controls (CSS-based effect)
    const glitchDurationRange = document.getElementById('glitchDuration') as HTMLInputElement;
    const glitchDurationNum = document.getElementById('glitchDurationVal') as HTMLInputElement;
    const glitchIntensityRange = document.getElementById('glitchIntensity') as HTMLInputElement;
    const glitchIntensityNum = document.getElementById('glitchIntensityVal') as HTMLInputElement;
    
    function updateGlitchVars() {
      const duration = parseFloat(glitchDurationRange.value);
      const intensity = parseFloat(glitchIntensityRange.value);
      document.documentElement.style.setProperty('--glitch-duration', duration + 'ms');
      document.documentElement.style.setProperty('--glitch-intensity', intensity + 'px');
    }
    
    [glitchDurationRange, glitchIntensityRange].forEach(input => {
      input.addEventListener('input', () => {
        if (input === glitchDurationRange) {
          glitchDurationNum.value = input.value;
        } else {
          glitchIntensityNum.value = input.value;
        }
        updateGlitchVars();
      });
    });
    
    [glitchDurationNum, glitchIntensityNum].forEach(input => {
      input.addEventListener('input', () => {
        if (input === glitchDurationNum) {
          glitchDurationRange.value = input.value;
        } else {
          glitchIntensityRange.value = input.value;
        }
        updateGlitchVars();
      });
    });
    
    updateGlitchVars(); // Initialize
    
    // Welcome glitch controls (CSS-based, for portfolio page)
    const welcomeGlitchDurationRange = document.getElementById('welcomeGlitchDuration') as HTMLInputElement;
    const welcomeGlitchDurationNum = document.getElementById('welcomeGlitchDurationVal') as HTMLInputElement;
    const welcomeGlitchIntensityRange = document.getElementById('welcomeGlitchIntensity') as HTMLInputElement;
    const welcomeGlitchIntensityNum = document.getElementById('welcomeGlitchIntensityVal') as HTMLInputElement;
    
    function updateWelcomeGlitchVars() {
      const duration = parseFloat(welcomeGlitchDurationRange.value);
      const intensity = parseFloat(welcomeGlitchIntensityRange.value);
      // Update CSS variables on the welcome glitch container if it exists
      const welcomeGlitch = document.getElementById('welcome-glitch');
      if (welcomeGlitch) {
        welcomeGlitch.style.setProperty('--welcome-glitch-duration', duration + 'ms');
        welcomeGlitch.style.setProperty('--welcome-glitch-intensity', intensity + 'px');
      }
      // Also set on document root for when portfolio loads
      document.documentElement.style.setProperty('--welcome-glitch-duration', duration + 'ms');
      document.documentElement.style.setProperty('--welcome-glitch-intensity', intensity + 'px');
    }
    
    [welcomeGlitchDurationRange, welcomeGlitchIntensityRange].forEach(input => {
      input.addEventListener('input', () => {
        if (input === welcomeGlitchDurationRange) {
          welcomeGlitchDurationNum.value = input.value;
        } else {
          welcomeGlitchIntensityNum.value = input.value;
        }
        updateWelcomeGlitchVars();
      });
    });
    
    [welcomeGlitchDurationNum, welcomeGlitchIntensityNum].forEach(input => {
      input.addEventListener('input', () => {
        if (input === welcomeGlitchDurationNum) {
          welcomeGlitchDurationRange.value = input.value;
        } else {
          welcomeGlitchIntensityRange.value = input.value;
        }
        updateWelcomeGlitchVars();
      });
    });
    
    updateWelcomeGlitchVars(); // Initialize
    
    const controls = [
      'hoverRadius', 'hoverFade', 'hoverMaxScale', 'repelStrength', 'colorIntensity', 'gumminess',
      'rippleSpeed', 'rippleWidth', 'rippleDuration', 'rippleColorIntensity',
      'colorPickupRange', 'colorVibrancy', 'colorSoftness'
    ];
    
    controls.forEach(id => {
      const rangeInput = document.getElementById(id) as HTMLInputElement;
      const numberInput = document.getElementById(id + 'Val') as HTMLInputElement;
      
      // Range slider updates number input
      rangeInput.addEventListener('input', () => {
        const val = parseFloat(rangeInput.value);
        (params as any)[id] = val;
        numberInput.value = val.toString();
      });
      
      // Number input updates range slider
      numberInput.addEventListener('input', () => {
        const val = parseFloat(numberInput.value);
        if (!isNaN(val)) {
          (params as any)[id] = val;
          rangeInput.value = val.toString();
        }
      });
      
      // Also update on blur (when user finishes typing)
      numberInput.addEventListener('blur', () => {
        const val = parseFloat(numberInput.value);
        if (!isNaN(val)) {
          // Clamp to range limits
          const min = parseFloat(rangeInput.min);
          const max = parseFloat(rangeInput.max);
          const clamped = Math.max(min, Math.min(max, val));
          (params as any)[id] = clamped;
          rangeInput.value = clamped.toString();
          numberInput.value = clamped.toString();
        }
      });
    });
    
    // Reset to defaults button
    const resetBtn = document.getElementById('reset-controls')!;
    resetBtn.addEventListener('click', () => {
      // Reset shader controls
      controls.forEach(id => {
        const rangeInput = document.getElementById(id) as HTMLInputElement;
        const numberInput = document.getElementById(id + 'Val') as HTMLInputElement;
        const defaultVal = (defaults as any)[id];
        
        rangeInput.value = defaultVal.toString();
        numberInput.value = defaultVal.toString();
        (params as any)[id] = defaultVal;
      });
      
      // Reset glitch controls (CSS-based)
      glitchDurationRange.value = defaults.glitchDuration.toString();
      glitchDurationNum.value = defaults.glitchDuration.toString();
      glitchIntensityRange.value = defaults.glitchIntensity.toString();
      glitchIntensityNum.value = defaults.glitchIntensity.toString();
      updateGlitchVars();
      
      // Reset welcome glitch controls
      welcomeGlitchDurationRange.value = defaults.welcomeGlitchDuration.toString();
      welcomeGlitchDurationNum.value = defaults.welcomeGlitchDuration.toString();
      welcomeGlitchIntensityRange.value = defaults.welcomeGlitchIntensity.toString();
      welcomeGlitchIntensityNum.value = defaults.welcomeGlitchIntensity.toString();
      updateWelcomeGlitchVars();
    });
  }
  
  setupControls();
  
  if (!gl) {
    console.error('WebGL not supported');
  } else {
    const vertexShaderSource = `
      attribute vec2 a_position;
      
      void main() {
        gl_Position = vec4(a_position, 0.0, 1.0);
      }
    `;

    const fragmentShaderSource = `
      precision highp float;
      
      uniform vec2 u_resolution;
      uniform vec2 u_mouse;
      uniform vec2 u_mouseVelocity;
      uniform float u_mouseSpeed;
      uniform float u_mouseActive;
      uniform float u_time;
      uniform vec2 u_clickPos;
      uniform float u_clickTime;
      
      // Image texture sampling
      uniform sampler2D u_headerTexture;
      uniform vec4 u_headerBounds; // x, y, width, height in pixels (y is flipped for WebGL)
      uniform vec2 u_textureSize; // Actual texture dimensions (may differ from header bounds)
      uniform float u_headerReady;
      
      // Controllable params
      uniform float u_hoverRadius;
      uniform float u_hoverFade;
      uniform float u_hoverMaxScale;
      uniform float u_repelStrength;
      uniform float u_colorIntensity;
      uniform float u_rippleSpeed;
      uniform float u_rippleWidth;
      uniform float u_rippleDuration;
      uniform float u_rippleColorIntensity;
      uniform float u_baseDotSize;
      uniform float u_dotRoundness;
      uniform float u_colorPickupRange;
      uniform float u_colorVibrancy;
      uniform float u_colorSoftness;
      
      // Hexagonal grid constants
      const float HEX_SIZE = 16.0; // Horizontal spacing
      const float HEX_HEIGHT = HEX_SIZE * 0.866; // Vertical spacing (sqrt(3)/2 for true hex)
      
      // Colors
      const vec3 BG_COLOR = vec3(0.051, 0.055, 0.067);
      const vec3 DOT_COLOR = vec3(0.110, 0.114, 0.125);
      const vec3 HOVER_COLOR = vec3(0.4, 0.45, 0.5); // Much brighter for visible gradient
      
      // Helper to get hex cell center
      vec2 getHexCenter(float col, float row) {
        float offset = mod(row, 2.0) * (HEX_SIZE * 0.5);
        return vec2(
          col * HEX_SIZE + offset + HEX_SIZE * 0.5,
          row * HEX_HEIGHT + HEX_HEIGHT * 0.5
        );
      }
      
      void main() {
        vec2 uv = gl_FragCoord.xy;
        vec2 mouse = u_mouse;
        float totalRadius = u_hoverRadius + u_hoverFade;
        
        // Find the closest hex cell center
        // First, get approximate row and column
        float row = floor(uv.y / HEX_HEIGHT);
        float rowOffset = mod(row, 2.0) * (HEX_SIZE * 0.5);
        float col = floor((uv.x - rowOffset) / HEX_SIZE);
        
        // Check this cell and neighboring cells to find the closest center
        vec2 cellCenter = getHexCenter(col, row);
        float minDist = distance(uv, cellCenter);
        
        // Check all 6 neighbors + adjacent row possibilities
        for (float dr = -1.0; dr <= 1.0; dr += 1.0) {
          for (float dc = -1.0; dc <= 1.0; dc += 1.0) {
            vec2 neighbor = getHexCenter(col + dc, row + dr);
            float d = distance(uv, neighbor);
            if (d < minDist) {
              minDist = d;
              cellCenter = neighbor;
            }
          }
        }
        
        // ===== REPEL EFFECT (Comet tail via elliptical stretch) =====
        // Stretch the repel zone behind the cursor based on movement
        vec2 repelledCenter = cellCenter;
        float cellDist = distance(cellCenter, mouse);
        
        if (u_repelStrength > 0.0) {
          // Vector from mouse to this cell
          vec2 toCell = cellCenter - mouse;
          
          // Get movement direction (or arbitrary if stationary)
          vec2 moveDir = u_mouseSpeed > 1.0 ? normalize(u_mouseVelocity) : vec2(1.0, 0.0);
          vec2 perpDir = vec2(-moveDir.y, moveDir.x);
          
          // Project cell position onto movement axis and perpendicular axis
          float alongMove = dot(toCell, moveDir);  // Positive = in front, negative = behind
          float perpMove = dot(toCell, perpDir);   // Side distance
          
          // Calculate stretch factor based on speed (more speed = longer tail)
          float stretchAmount = smoothstep(0.0, 15.0, u_mouseSpeed) * 2.5;
          
          // Elliptical distance: stretch BEHIND cursor (negative alongMove)
          // Front stays circular, back stretches into tail
          float tailStretch = 1.0;
          if (alongMove < 0.0) {
            // Behind cursor - stretch the effective radius
            tailStretch = 1.0 + stretchAmount;
          }
          
          // Calculate effective distance using elliptical formula
          // Front: normal circle, Back: stretched ellipse
          float effectiveAlongDist = alongMove / tailStretch;
          float effectiveDist = length(vec2(effectiveAlongDist, perpMove));
          
          // Use effectiveDist for determining if in repel zone
          // But use actual cellDist for the repel direction/strength
          if (effectiveDist < totalRadius && cellDist > 0.001) {
            vec2 awayDir = normalize(toCell);
            float repelFactor = 1.0 - (effectiveDist / totalRadius);
            repelFactor = repelFactor * repelFactor;
            
            // Slightly reduce strength in the tail region
            float tailFade = alongMove < 0.0 ? mix(1.0, 0.7, smoothstep(0.0, totalRadius * tailStretch, -alongMove)) : 1.0;
            
            vec2 repelOffset = awayDir * u_repelStrength * repelFactor * tailFade;
            repelledCenter = cellCenter + repelOffset * u_mouseActive;
          }
        }
        
        // Distance from this PIXEL to mouse (for COLOR - smooth gradient)
        float pixelDist = distance(uv, mouse);
        
        // ===== HOVER EFFECT =====
        // Size factor based on ORIGINAL cell distance (before repel) so repel doesn't kill scaling
        float sizeFactor = (1.0 - clamp(cellDist / totalRadius, 0.0, 1.0)) * u_mouseActive;
        sizeFactor = sizeFactor * sizeFactor;
        
        // Color factor based on PIXEL distance - linear 100% at center to 0% at edge
        float colorFactor = (1.0 - clamp(pixelDist / totalRadius, 0.0, 1.0)) * u_mouseActive;
        
        // Local position relative to REPELLED center
        vec2 localPos = uv - repelledCenter;
        
        // ===== SCALE EFFECT =====
        float scaleRange = u_hoverMaxScale - u_baseDotSize;
        float dotSize = u_baseDotSize + sizeFactor * scaleRange;
        
        // ===== CLICK RIPPLE EFFECT =====
        float timeSinceClick = u_time - u_clickTime;
        float distToClick = distance(cellCenter, u_clickPos);
        float rippleRadius = timeSinceClick * u_rippleSpeed;
        
        float ringDist = abs(distToClick - rippleRadius);
        float inRing = 1.0 - smoothstep(0.0, u_rippleWidth, ringDist);
        float rippleFade = 1.0 - smoothstep(0.0, u_rippleDuration, timeSinceClick);
        inRing *= rippleFade;
        
        float rippleScale = inRing * scaleRange * 0.8;
        dotSize = max(dotSize, u_baseDotSize + rippleScale);
        
        // ===== DRAW DOT (blend between square and circle) =====
        float halfSize = dotSize * 0.5;
        
        // Square distance (Chebyshev)
        float squareDist = max(abs(localPos.x), abs(localPos.y));
        // Circle distance (Euclidean)
        float circleDist = length(localPos);
        // Blend based on roundness
        float dist = mix(squareDist, circleDist, u_dotRoundness);
        
        // ===== COLOR GRADIENT =====
        // Dot color based on distance - linear gradient from center to edge
        vec3 dotColor = mix(DOT_COLOR, HOVER_COLOR, colorFactor * u_colorIntensity);
        
        // Ripple color effect - capped at hover color intensity (never brighter than hover)
        float rippleColorEffect = inRing * min(u_rippleColorIntensity, u_colorIntensity);
        dotColor = mix(dotColor, HOVER_COLOR, rippleColorEffect);
        
        // ===== SAMPLE COLOR FROM COLOR MAP (drawImage.png) =====
        // Flashlight effect with wide sampling for smooth transitions
        vec2 headerPos = u_headerBounds.xy;
        vec2 headerSize = u_headerBounds.zw;
        vec2 texSize = u_textureSize;
        if (u_headerReady > 0.5 && headerSize.x > 0.0 && headerSize.y > 0.0 && texSize.x > 0.0) {
          
          vec2 texScale = texSize / headerSize;
          float effectStrength = max(sizeFactor, inRing * 0.5);
          
          vec2 mouseRel = mouse - headerPos;
          vec2 mouseOnImage = clamp(mouseRel, vec2(0.0), headerSize);
          float mouseDistFromImage = distance(mouseRel, mouseOnImage);
          
          if (effectStrength > 0.001 && mouseDistFromImage < u_colorPickupRange) {
            vec2 mouseOnImageClamped = clamp(mouseRel, vec2(0.0), headerSize - vec2(1.0));
            vec2 texMousePos = mouseOnImageClamped * texScale;
            
            // Wide sampling for smooth color transitions
            vec3 headerColor = vec3(0.0);
            float totalWeight = 0.0;
            float baseRadius = u_colorSoftness * 3.0;
            
            // Center sample
            vec2 centerUV = vec2(texMousePos.x / texSize.x, 1.0 - (texMousePos.y / texSize.y));
            vec4 centerSample = texture2D(u_headerTexture, centerUV);
            float centerBright = (centerSample.r + centerSample.g + centerSample.b) / 3.0;
            headerColor += centerSample.rgb * 2.0;
            totalWeight += 2.0;
            
            // Ring samples for blending
            for (float ring = 1.0; ring <= 5.0; ring += 1.0) {
              float ringRadius = baseRadius * ring;
              float ringWeight = exp(-ring * 0.3);
              
              for (float angle = 0.0; angle < 6.28318; angle += 0.785) {
                vec2 offset = vec2(cos(angle), sin(angle)) * ringRadius;
                vec2 sampleUV = vec2(
                  (texMousePos.x + offset.x) / texSize.x,
                  1.0 - ((texMousePos.y + offset.y) / texSize.y)
                );
                sampleUV = clamp(sampleUV, vec2(0.0), vec2(1.0));
                
                vec4 ringSample = texture2D(u_headerTexture, sampleUV);
                headerColor += ringSample.rgb * ringWeight;
                totalWeight += ringWeight;
              }
            }
            
            headerColor = headerColor / totalWeight;
            
            // Ignore very dark results
            float finalBrightness = (headerColor.r + headerColor.g + headerColor.b) / 3.0;
            float colorValid = smoothstep(0.02, 0.1, finalBrightness);
            
            float mouseFade = 1.0 - smoothstep(0.0, u_colorPickupRange, mouseDistFromImage);
            float finalVibrancy = effectStrength * colorValid * mouseFade * u_colorVibrancy;
            
            dotColor = mix(dotColor, headerColor, clamp(finalVibrancy, 0.0, 1.0));
          }
        }
        
        // ===== SOFT-EDGED DOTS for smooth gradient appearance =====
        // Instead of hard edge (inDot ? dotColor : BG_COLOR), use soft blending
        // This creates anti-aliased dots that visually blend into a smooth gradient
        float edgeSoftness = 1.5; // pixels of softness at dot edge
        float dotAlpha = 1.0 - smoothstep(halfSize - edgeSoftness, halfSize + edgeSoftness, dist);
        
        // Blend dot color with background based on soft alpha
        vec3 color = mix(BG_COLOR, dotColor, dotAlpha);
        
        gl_FragColor = vec4(color, 1.0);
      }
    `;

    function compileShader(source: string, type: number) {
      const shader = gl!.createShader(type)!;
      gl!.shaderSource(shader, source);
      gl!.compileShader(shader);
      
      if (!gl!.getShaderParameter(shader, gl!.COMPILE_STATUS)) {
        console.error('Shader compile error:', gl!.getShaderInfoLog(shader));
        return null;
      }
      return shader;
    }

    const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
    const fragmentShader = compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);

    if (!vertexShader || !fragmentShader) {
      throw new Error('Failed to compile shaders');
    }

    const program = gl.createProgram()!;
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);

    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      console.error('Program link error:', gl.getProgramInfoLog(program));
    }

    gl.useProgram(program);

    const positions = new Float32Array([
      -1, -1,  1, -1,  -1, 1,
      -1,  1,  1, -1,   1, 1,
    ]);

    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

    const positionLocation = gl.getAttribLocation(program, 'a_position');
    gl.enableVertexAttribArray(positionLocation);
    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

    // Uniforms
    const resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
    const mouseLocation = gl.getUniformLocation(program, 'u_mouse');
    const mouseVelocityLocation = gl.getUniformLocation(program, 'u_mouseVelocity');
    const mouseSpeedLocation = gl.getUniformLocation(program, 'u_mouseSpeed');
    const mouseActiveLocation = gl.getUniformLocation(program, 'u_mouseActive');
    const timeLocation = gl.getUniformLocation(program, 'u_time');
    const clickPosLocation = gl.getUniformLocation(program, 'u_clickPos');
    const clickTimeLocation = gl.getUniformLocation(program, 'u_clickTime');
    
    // Header texture uniforms
    const headerTextureLocation = gl.getUniformLocation(program, 'u_headerTexture');
    const headerBoundsLocation = gl.getUniformLocation(program, 'u_headerBounds');
    const textureSizeLocation = gl.getUniformLocation(program, 'u_textureSize');
    const headerReadyLocation = gl.getUniformLocation(program, 'u_headerReady');
    
    const hoverRadiusLocation = gl.getUniformLocation(program, 'u_hoverRadius');
    const hoverFadeLocation = gl.getUniformLocation(program, 'u_hoverFade');
    const hoverMaxScaleLocation = gl.getUniformLocation(program, 'u_hoverMaxScale');
    const repelStrengthLocation = gl.getUniformLocation(program, 'u_repelStrength');
    const colorIntensityLocation = gl.getUniformLocation(program, 'u_colorIntensity');
    const rippleSpeedLocation = gl.getUniformLocation(program, 'u_rippleSpeed');
    const rippleWidthLocation = gl.getUniformLocation(program, 'u_rippleWidth');
    const rippleDurationLocation = gl.getUniformLocation(program, 'u_rippleDuration');
    const rippleColorIntensityLocation = gl.getUniformLocation(program, 'u_rippleColorIntensity');
    const baseDotSizeLocation = gl.getUniformLocation(program, 'u_baseDotSize');
    const dotRoundnessLocation = gl.getUniformLocation(program, 'u_dotRoundness');
    const colorPickupRangeLocation = gl.getUniformLocation(program, 'u_colorPickupRange');
    const colorVibrancyLocation = gl.getUniformLocation(program, 'u_colorVibrancy');
    const colorSoftnessLocation = gl.getUniformLocation(program, 'u_colorSoftness');

    // State
    let mouseX = -9999;
    let mouseY = -9999;
    let targetMouseX = -9999;
    let targetMouseY = -9999;
    let mouseActive = 0;
    let targetMouseActive = 0;
    let clickX = -9999;
    let clickY = -9999;
    let clickTime = -9999;
    
    // Velocity tracking for comet tail
    let prevMouseX = -9999;
    let prevMouseY = -9999;
    let mouseVelX = 0;
    let mouseVelY = 0;
    let mouseSpeed = 0;

    document.addEventListener('mousemove', (e) => {
      const dpr = window.devicePixelRatio || 1;
      targetMouseX = e.clientX * dpr;
      targetMouseY = (window.innerHeight - e.clientY) * dpr;
      targetMouseActive = 1;
      // Snap position immediately when re-entering
      if (mouseActive < 0.1) {
        mouseX = targetMouseX;
        mouseY = targetMouseY;
      }
    });

    document.addEventListener('mouseleave', () => {
      targetMouseActive = 0;
    });

    document.addEventListener('click', (e) => {
      // Ignore clicks on controls and password form
      if ((e.target as HTMLElement).closest('#shader-controls')) return;
      if ((e.target as HTMLElement).closest('#password-form')) return;
      
      // Ignore synthetic clicks (e.g., from keyboard Enter) with no real coordinates
      if (e.clientX === 0 && e.clientY === 0) return;
      
      const dpr = window.devicePixelRatio || 1;
      clickX = e.clientX * dpr;
      clickY = (window.innerHeight - e.clientY) * dpr;
      clickTime = (Date.now() - startTime) / 1000;
    });

    function resize() {
      const dpr = window.devicePixelRatio || 1;
      canvas.width = window.innerWidth * dpr;
      canvas.height = window.innerHeight * dpr;
      canvas.style.width = window.innerWidth + 'px';
      canvas.style.height = window.innerHeight + 'px';
      gl!.viewport(0, 0, canvas.width, canvas.height);
    }

    window.addEventListener('resize', resize);
    resize();

    // ===== HEADER TEXTURE SETUP =====
    let headerTexture: WebGLTexture | null = null;
    let headerReady = 0;
    let headerBounds = { x: 0, y: 0, width: 0, height: 0 };
    let textureSize = { width: 0, height: 0 }; // Actual color map texture dimensions
    
    function updateHeaderBounds() {
      const headerImg = document.querySelector('img[src*="ansi-heading"]') as HTMLImageElement;
      if (headerImg) {
        const rect = headerImg.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        // Convert to WebGL coordinates (y-flipped)
        headerBounds = {
          x: rect.left * dpr,
          y: (window.innerHeight - rect.bottom) * dpr, // Flip Y for WebGL
          width: rect.width * dpr,
          height: rect.height * dpr
        };
      }
    }
    
    function loadHeaderTexture() {
      const headerImg = document.querySelector('img[src*="ansi-heading"]') as HTMLImageElement;
      if (!headerImg) {
        // Try again later if image not found yet
        setTimeout(loadHeaderTexture, 100);
        return;
      }
      
      // Load a SEPARATE image for the color sampling texture
      // This allows us to use a different/simplified color map for the effect
      const colorMapImg = new Image();
      colorMapImg.crossOrigin = 'anonymous';
      colorMapImg.src = '/drawImage.png';
      
      // Create offscreen canvas to render the image
      const offscreen = document.createElement('canvas');
      const ctx = offscreen.getContext('2d')!;
      
      const loadImage = () => {
        // Set canvas size to the color map image size
        const texW = colorMapImg.naturalWidth || colorMapImg.width;
        const texH = colorMapImg.naturalHeight || colorMapImg.height;
        offscreen.width = texW;
        offscreen.height = texH;
        
        // Store texture dimensions for proper UV mapping
        textureSize = { width: texW, height: texH };
        
        // Draw the COLOR MAP image (not the displayed header)
        ctx.drawImage(colorMapImg, 0, 0);
        
        // Create WebGL texture
        headerTexture = gl!.createTexture();
        gl!.bindTexture(gl!.TEXTURE_2D, headerTexture);
        
        // Upload the canvas to the texture
        gl!.texImage2D(gl!.TEXTURE_2D, 0, gl!.RGBA, gl!.RGBA, gl!.UNSIGNED_BYTE, offscreen);
        
        // Set texture parameters
        gl!.texParameteri(gl!.TEXTURE_2D, gl!.TEXTURE_WRAP_S, gl!.CLAMP_TO_EDGE);
        gl!.texParameteri(gl!.TEXTURE_2D, gl!.TEXTURE_WRAP_T, gl!.CLAMP_TO_EDGE);
        gl!.texParameteri(gl!.TEXTURE_2D, gl!.TEXTURE_MIN_FILTER, gl!.LINEAR);
        gl!.texParameteri(gl!.TEXTURE_2D, gl!.TEXTURE_MAG_FILTER, gl!.LINEAR);
        
        headerReady = 1;
        updateHeaderBounds(); // Still tracks the VISIBLE header position
      };
      
      colorMapImg.onload = loadImage;
      
      // Also update bounds when the visible header loads (for positioning)
      if (headerImg.complete) {
        updateHeaderBounds();
      } else {
        headerImg.onload = () => updateHeaderBounds();
      }
    }
    
    // Load texture and update bounds on resize/scroll/custom event
    loadHeaderTexture();
    window.addEventListener('resize', updateHeaderBounds);
    window.addEventListener('scroll', updateHeaderBounds);
    window.addEventListener('headerMoved', updateHeaderBounds);
    
    // Disable color sampling when header is removed
    window.addEventListener('headerRemoved', () => {
      headerReady = 0;
      headerBounds = { x: 0, y: 0, width: 0, height: 0 };
    });

    let startTime = Date.now();
    
    function render() {
      const time = (Date.now() - startTime) / 1000;
      
      // Only update position when mouse is active
      if (targetMouseActive > 0.5) {
        mouseX += (targetMouseX - mouseX) * params.gumminess;
        mouseY += (targetMouseY - mouseY) * params.gumminess;
      }
      
      // Calculate velocity for comet tail direction
      const rawVelX = mouseX - prevMouseX;
      const rawVelY = mouseY - prevMouseY;
      const rawSpeed = Math.sqrt(rawVelX * rawVelX + rawVelY * rawVelY);
      
      // Smooth velocity to avoid jitter
      mouseVelX += (rawVelX - mouseVelX) * 0.15;
      mouseVelY += (rawVelY - mouseVelY) * 0.15;
      mouseSpeed += (rawSpeed - mouseSpeed) * 0.1;
      
      // Store previous position
      prevMouseX = mouseX;
      prevMouseY = mouseY;
      
      // Smoothly fade mouseActive in/out
      mouseActive += (targetMouseActive - mouseActive) * 0.08;

      gl!.uniform2f(resolutionLocation, canvas.width, canvas.height);
      gl!.uniform2f(mouseLocation, mouseX, mouseY);
      gl!.uniform2f(mouseVelocityLocation, mouseVelX, mouseVelY);
      gl!.uniform1f(mouseSpeedLocation, mouseSpeed);
      gl!.uniform1f(mouseActiveLocation, mouseActive);
      gl!.uniform1f(timeLocation, time);
      gl!.uniform2f(clickPosLocation, clickX, clickY);
      gl!.uniform1f(clickTimeLocation, clickTime);
      
      // Header texture uniforms
      if (headerTexture) {
        gl!.activeTexture(gl!.TEXTURE0);
        gl!.bindTexture(gl!.TEXTURE_2D, headerTexture);
        gl!.uniform1i(headerTextureLocation, 0);
      }
      gl!.uniform4f(headerBoundsLocation, headerBounds.x, headerBounds.y, headerBounds.width, headerBounds.height);
      gl!.uniform2f(textureSizeLocation, textureSize.width, textureSize.height);
      gl!.uniform1f(headerReadyLocation, headerReady);
      
      // Update from control panel
      gl!.uniform1f(hoverRadiusLocation, params.hoverRadius);
      gl!.uniform1f(hoverFadeLocation, params.hoverFade);
      gl!.uniform1f(hoverMaxScaleLocation, params.hoverMaxScale);
      gl!.uniform1f(repelStrengthLocation, params.repelStrength);
      gl!.uniform1f(colorIntensityLocation, params.colorIntensity);
      gl!.uniform1f(rippleSpeedLocation, params.rippleSpeed);
      gl!.uniform1f(rippleWidthLocation, params.rippleWidth);
      gl!.uniform1f(rippleDurationLocation, params.rippleDuration);
      gl!.uniform1f(rippleColorIntensityLocation, params.rippleColorIntensity);
      gl!.uniform1f(baseDotSizeLocation, params.baseDotSize);
      gl!.uniform1f(dotRoundnessLocation, params.dotRoundness);
      gl!.uniform1f(colorPickupRangeLocation, params.colorPickupRange);
      gl!.uniform1f(colorVibrancyLocation, params.colorVibrancy);
      gl!.uniform1f(colorSoftnessLocation, params.colorSoftness);

      gl!.drawArrays(gl!.TRIANGLES, 0, 6);
      requestAnimationFrame(render);
    }

    render();
  }
</script>
