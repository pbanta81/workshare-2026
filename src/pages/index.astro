---
import Layout from '../layouts/Layout.astro';
---

<Layout>
  <!-- Hero Section -->
  <section class="app-shell flex flex-col pt-[6vh] md:pt-0 md:justify-center md:items-center">
    <div class="w-full md:max-w-4xl md:mx-auto md:px-6 animate-fade-in opacity-0">
      <div class="glitch-container" id="glitch-container">
        <img 
          src="/ansi-heading.png" 
          alt="Patrick Banta" 
          class="glitch-img glitch-base"
          style="image-rendering: pixelated;"
        />
        <img 
          src="/ansi-heading.png" 
          alt="" 
          class="glitch-img glitch-r"
          style="image-rendering: pixelated;"
          aria-hidden="true"
        />
        <img 
          src="/ansi-heading.png" 
          alt="" 
          class="glitch-img glitch-b"
          style="image-rendering: pixelated;"
          aria-hidden="true"
        />
      </div>
      
      <!-- Password Input -->
      <div class="password-container">
        <form id="password-form" class="password-form">
          <label for="password-input" class="input-label">ENTER PASSWORD</label>
          <div class="input-glitch-container">
            <div class="input-wrapper">
            <span class="input-prompt">►</span>
            <input 
              type="password" 
              id="password-input"
              class="password-input"
              autocomplete="off"
              spellcheck="false"
            />
            <span id="custom-cursor" class="custom-cursor"></span>
            <button type="submit" class="submit-btn" aria-label="Submit">
              <span class="submit-arrow">↵</span>
            </button>
          </div>
          <div class="input-glitch-r"></div>
          <div class="input-glitch-b"></div>
          </div>
          <div id="password-status" class="password-status"></div>
        </form>
      </div>
    </div>
  </section>
  
  <!-- Portfolio Content (loaded dynamically after successful password) -->
  <div id="portfolio-content" class="portfolio-content hidden">
    <div class="portfolio-inner">
      <article id="portfolio-body" class="portfolio-body"></article>
    </div>
  </div>
</Layout>

<style>
  :root {
    --glitch-duration: 380ms;
    --glitch-intensity: 20px;
  }
  
  /* App shell - anchored to visual viewport */
  .app-shell {
    min-height: 100vh;
    min-height: 100svh;
    height: var(--vvh, 100svh);
    transform: translateY(var(--vvTop, 0px));
    transition: height 0.1s ease-out, transform 0.1s ease-out;
  }
  
  @media (min-width: 768px) {
    .app-shell {
      min-height: 100vh;
      height: auto;
      transform: none;
    }
  }
  
  /* Success transition animations */
  .password-container {
    transition: opacity 0.5s ease-out;
    margin-top: 12px;
    padding: 0 16px;
  }
  
  @media (min-width: 768px) {
    .password-container {
      margin-top: 24px;
      padding: 0;
    }
  }
  
  .password-container.fade-out {
    opacity: 0;
    pointer-events: none;
  }
  
  .glitch-container {
    transition: transform 1.5s ease-in-out;
  }
  
  .glitch-container.move-to-top {
    /* Transform value set via JavaScript */
  }
  
  .glitch-container {
    position: relative;
    cursor: pointer;
    overflow: hidden;
  }
  
  .glitch-img {
    width: 100%;
    height: auto;
    display: block;
  }
  
  /* Mobile: Scale up image to fill viewport (crops empty edges) */
  @media (max-width: 767px) {
    .glitch-container {
      width: 100vw;
      overflow: hidden;
    }
    
    .glitch-img {
      width: 125vw;
      max-width: none;
      margin-left: -12.5vw;
    }
    
  }
  
  .glitch-r,
  .glitch-b {
    position: absolute;
    top: 0;
    left: 0;
    opacity: 0;
    pointer-events: none;
  }
  
  .glitch-r {
    mix-blend-mode: screen;
  }
  
  .glitch-b {
    mix-blend-mode: screen;
  }
  
  /* Active glitch state */
  .glitch-container.glitching .glitch-r,
  .glitch-container.glitching .glitch-b {
    opacity: 0.8;
  }
  
  .glitch-container.glitching .glitch-r {
    animation: glitch-r calc(var(--glitch-duration) * 0.4) steps(2) infinite;
  }
  
  .glitch-container.glitching .glitch-b {
    animation: glitch-b calc(var(--glitch-duration) * 0.4) steps(2) infinite;
  }
  
  .glitch-container.glitching .glitch-base {
    animation: glitch-base calc(var(--glitch-duration) * 0.5) steps(3) infinite;
  }
  
  @keyframes glitch-r {
    0% {
      transform: translate(var(--glitch-intensity), calc(var(--glitch-intensity) * -0.25));
      clip-path: polygon(0 20%, 100% 20%, 100% 30%, 0 30%);
      filter: hue-rotate(-60deg) saturate(2);
    }
    25% {
      transform: translate(calc(var(--glitch-intensity) * -1), calc(var(--glitch-intensity) * 0.125));
      clip-path: polygon(0 60%, 100% 60%, 100% 65%, 0 65%);
      filter: hue-rotate(-60deg) saturate(2);
    }
    50% {
      transform: translate(calc(var(--glitch-intensity) * 0.375), calc(var(--glitch-intensity) * -0.125));
      clip-path: polygon(0 80%, 100% 80%, 100% 90%, 0 90%);
      filter: hue-rotate(-60deg) saturate(2);
    }
    75% {
      transform: translate(calc(var(--glitch-intensity) * -0.625), calc(var(--glitch-intensity) * 0.25));
      clip-path: polygon(0 10%, 100% 10%, 100% 20%, 0 20%);
      filter: hue-rotate(-60deg) saturate(2);
    }
    100% {
      transform: translate(calc(var(--glitch-intensity) * 0.75), calc(var(--glitch-intensity) * -0.25));
      clip-path: polygon(0 45%, 100% 45%, 100% 55%, 0 55%);
      filter: hue-rotate(-60deg) saturate(2);
    }
  }
  
  @keyframes glitch-b {
    0% {
      transform: translate(calc(var(--glitch-intensity) * -0.5), calc(var(--glitch-intensity) * 0.25));
      clip-path: polygon(0 70%, 100% 70%, 100% 80%, 0 80%);
      filter: hue-rotate(60deg) saturate(2);
    }
    25% {
      transform: translate(calc(var(--glitch-intensity) * 0.75), calc(var(--glitch-intensity) * -0.125));
      clip-path: polygon(0 35%, 100% 35%, 100% 45%, 0 45%);
      filter: hue-rotate(60deg) saturate(2);
    }
    50% {
      transform: translate(calc(var(--glitch-intensity) * -0.625), calc(var(--glitch-intensity) * 0.125));
      clip-path: polygon(0 5%, 100% 5%, 100% 15%, 0 15%);
      filter: hue-rotate(60deg) saturate(2);
    }
    75% {
      transform: translate(calc(var(--glitch-intensity) * 0.5), calc(var(--glitch-intensity) * -0.25));
      clip-path: polygon(0 50%, 100% 50%, 100% 60%, 0 60%);
      filter: hue-rotate(60deg) saturate(2);
    }
    100% {
      transform: translate(calc(var(--glitch-intensity) * -0.75), calc(var(--glitch-intensity) * 0.125));
      clip-path: polygon(0 85%, 100% 85%, 100% 95%, 0 95%);
      filter: hue-rotate(60deg) saturate(2);
    }
  }
  
  @keyframes glitch-base {
    0%, 100% {
      transform: translate(0, 0) skewX(0deg);
    }
    20% {
      transform: translate(calc(var(--glitch-intensity) * -0.375), 0) skewX(-0.5deg);
    }
    40% {
      transform: translate(calc(var(--glitch-intensity) * 0.375), 0) skewX(0.5deg);
    }
    60% {
      transform: translate(calc(var(--glitch-intensity) * -0.25), 0) skewX(-0.3deg);
    }
    80% {
      transform: translate(calc(var(--glitch-intensity) * 0.25), 0) skewX(0.3deg);
    }
  }
  
  /* White flash glitch effect for success state */
  .glitch-container.flash-white .glitch-base {
    animation: flash-white-base 600ms ease-out forwards;
  }
  
  .glitch-container.flash-white .glitch-r,
  .glitch-container.flash-white .glitch-b {
    opacity: 0.9;
    animation: flash-white-layer 600ms ease-out forwards;
  }
  
  @keyframes flash-white-base {
    0% {
      filter: brightness(1) saturate(1);
      transform: translate(0, 0);
    }
    8% {
      filter: brightness(8) saturate(0);
      transform: translate(-2px, 0);
    }
    15% {
      filter: brightness(15) saturate(0);
      transform: translate(2px, 0);
    }
    25% {
      filter: brightness(3) saturate(0.3);
      transform: translate(0, 0);
    }
    50% {
      filter: brightness(1.5) saturate(0.7);
      transform: translate(0, 0);
    }
    100% {
      filter: brightness(1) saturate(1);
      transform: translate(0, 0);
    }
  }
  
  @keyframes flash-white-layer {
    0% {
      filter: brightness(1) saturate(2);
      clip-path: polygon(0 0, 100% 0, 100% 100%, 0 100%);
      transform: translate(3px, 0);
      opacity: 0.9;
    }
    8% {
      filter: brightness(10) saturate(0);
      clip-path: polygon(0 15%, 100% 15%, 100% 85%, 0 85%);
      transform: translate(-4px, 0);
      opacity: 1;
    }
    15% {
      filter: brightness(15) saturate(0);
      clip-path: polygon(0 0, 100% 0, 100% 100%, 0 100%);
      transform: translate(2px, 0);
      opacity: 1;
    }
    30% {
      filter: brightness(3) saturate(0.5);
      clip-path: polygon(0 0, 100% 0, 100% 100%, 0 100%);
      transform: translate(0, 0);
      opacity: 0.5;
    }
    100% {
      filter: brightness(1) saturate(1);
      clip-path: polygon(0 0, 100% 0, 100% 100%, 0 100%);
      transform: translate(0, 0);
      opacity: 0;
    }
  }
  
  /* Iris out effect - animated */
  .glitch-container {
    clip-path: circle(100% at 50% 50%);
  }
  
  .glitch-container.fade-out {
    opacity: 0;
    transition: opacity 0.4s ease-out;
  }
  
  /* CRAZY glitch mode - JS-driven random chaos */
  .glitch-container.glitch-crazy .glitch-r,
  .glitch-container.glitch-crazy .glitch-b {
    opacity: 1;
  }
  
  /* Password Input - ANSI/Pixel Style */
  .password-container {
    display: flex;
    justify-content: center;
  }
  
  .password-form {
    width: 100%;
    max-width: 400px;
  }
  
  .input-label {
    display: block;
    font-family: 'Berkeley Mono', 'Courier New', monospace;
    font-weight: bold;
    font-size: 12px;
    color: #22d3ee;
    letter-spacing: 2px;
    margin-bottom: 8px;
    text-align: left;
  }
  
  .input-wrapper {
    display: flex;
    align-items: center;
    background: #0D0E11;
    border: 2px solid #22d3ee;
    padding: 0;
    font-family: 'Berkeley Mono', 'Courier New', monospace;
    position: relative;
  }
  
  .input-prompt {
    color: #22d3ee;
    padding: 12px;
    padding-right: 8px;
    font-size: 16px;
    animation: blink 1s step-end infinite;
  }
  
  @keyframes blink {
    50% { opacity: 0; }
  }
  
  .password-input {
    flex: 1;
    background: transparent;
    border: none;
    color: #22d3ee;
    font-family: inherit;
    font-size: 16px; /* Prevents iOS zoom on focus */
    padding: 12px 8px;
    letter-spacing: 2px;
    text-transform: uppercase;
    outline: none;
    caret-color: transparent; /* Hide native caret */
  }
  
  /* Custom cursor */
  .custom-cursor {
    position: absolute;
    width: 2px;
    height: 18px;
    background: #22d3ee;
    pointer-events: none;
    opacity: 0;
    top: 50%;
    transform: translateY(-50%);
  }
  
  .input-wrapper:focus-within .custom-cursor {
    opacity: 1;
  }
  
  .input-wrapper:focus-within {
    background: #0E181C;
  }
  
  .submit-btn {
    background: transparent;
    border: none;
    border-left: 2px solid #22d3ee;
    color: #22d3ee;
    padding: 12px 16px;
    cursor: pointer;
    font-family: inherit;
    font-size: 16px;
    transition: all 0.2s;
  }
  
  .submit-btn:hover {
    background: rgba(34, 211, 238, 0.2);
  }
  
  .submit-arrow {
    display: block;
  }
  
  .password-status {
    margin-top: 12px;
    font-family: 'Berkeley Mono', 'Courier New', monospace;
    font-size: 12px;
    letter-spacing: 1px;
    text-align: left;
    min-height: 20px;
  }
  
  .password-status.error {
    color: #f87171;
  }
  
  .password-status.success {
    color: #4ade80;
  }
  
  .password-status.loading {
    color: #fbbf24;
  }
  
  /* Input wrapper states */
  .input-wrapper.error {
    border-color: #f87171;
    animation: shake 0.4s ease-in-out;
  }
  
  .input-wrapper.success {
    border-color: #4ade80;
  }
  
  @keyframes shake {
    0%, 100% { transform: translateX(0); }
    20% { transform: translateX(-8px); }
    40% { transform: translateX(8px); }
    60% { transform: translateX(-4px); }
    80% { transform: translateX(4px); }
  }
  
  /* Input glitch effect */
  .input-glitch-container {
    position: relative;
    overflow: visible;
  }
  
  .input-glitch-r,
  .input-glitch-b {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    pointer-events: none;
    opacity: 0;
    border: 2px solid transparent;
  }
  
  .input-glitch-r {
    border-color: #f87171;
    mix-blend-mode: screen;
  }
  
  .input-glitch-b {
    border-color: #60a5fa;
    mix-blend-mode: screen;
  }
  
  .input-wrapper.input-glitching {
    animation: input-glitch-base 450ms steps(4) forwards;
  }
  
  .input-wrapper.input-glitching ~ .input-glitch-r {
    opacity: 1;
    animation: input-glitch-r 450ms steps(3) forwards;
  }
  
  .input-wrapper.input-glitching ~ .input-glitch-b {
    opacity: 1;
    animation: input-glitch-b 450ms steps(3) forwards;
  }
  
  @keyframes input-glitch-r {
    0% {
      transform: translate(8px, -4px);
      clip-path: polygon(0 0, 100% 0, 100% 45%, 0 45%);
    }
    25% {
      transform: translate(-12px, 3px);
      clip-path: polygon(0 55%, 100% 55%, 100% 100%, 0 100%);
    }
    50% {
      transform: translate(10px, -4px);
      clip-path: polygon(0 20%, 100% 20%, 100% 60%, 0 60%);
    }
    75% {
      transform: translate(-8px, 5px);
      clip-path: polygon(0 70%, 100% 70%, 100% 90%, 0 90%);
    }
    100% {
      transform: translate(0, 0);
      opacity: 0;
    }
  }
  
  @keyframes input-glitch-b {
    0% {
      transform: translate(-7px, 5px);
      clip-path: polygon(0 55%, 100% 55%, 100% 100%, 0 100%);
    }
    25% {
      transform: translate(10px, -3px);
      clip-path: polygon(0 0, 100% 0, 100% 35%, 0 35%);
    }
    50% {
      transform: translate(-9px, 3px);
      clip-path: polygon(0 40%, 100% 40%, 100% 80%, 0 80%);
    }
    75% {
      transform: translate(7px, -5px);
      clip-path: polygon(0 10%, 100% 10%, 100% 30%, 0 30%);
    }
    100% {
      transform: translate(0, 0);
      opacity: 0;
    }
  }
  
  @keyframes input-glitch-base {
    0%, 100% {
      transform: translate(0, 0) skewX(0deg) skewY(0deg);
    }
    15% {
      transform: translate(-8px, 3px) skewX(-4deg) skewY(1deg);
    }
    30% {
      transform: translate(10px, -4px) skewX(3deg) skewY(-2deg);
    }
    45% {
      transform: translate(-6px, 5px) skewX(-3deg) skewY(1.5deg);
    }
    60% {
      transform: translate(8px, -3px) skewX(4deg) skewY(-1deg);
    }
    75% {
      transform: translate(-4px, 4px) skewX(-2deg) skewY(2deg);
    }
    90% {
      transform: translate(5px, -2px) skewX(2deg) skewY(-1deg);
    }
  }
  
  /* Portfolio Content Styles */
  .portfolio-content {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    overflow-y: auto;
    opacity: 0;
    transition: opacity 0.8s ease-out;
  }
  
  .portfolio-content.visible {
    opacity: 1;
  }
  
  .portfolio-content.hidden {
    display: none;
  }
  
  .portfolio-inner {
    max-width: 800px;
    margin: 0 auto;
  }
  
  .portfolio-header {
    margin-bottom: 48px;
    padding-bottom: 32px;
    border-bottom: 1px solid rgba(34, 211, 238, 0.2);
  }
  
  .portfolio-title {
    font-family: 'Berkeley Mono', 'Courier New', monospace;
    font-size: 28px;
    font-weight: bold;
    color: #22d3ee;
    margin: 0 0 16px;
    text-transform: uppercase;
    letter-spacing: 2px;
  }
  
  .portfolio-meta {
    font-family: 'Berkeley Mono', 'Courier New', monospace;
    font-size: 14px;
    color: rgba(255, 255, 255, 0.6);
    margin-bottom: 24px;
  }
  
  .portfolio-divider {
    margin: 0 12px;
    color: #22d3ee;
  }
  
  .portfolio-summary {
    font-size: 18px;
    line-height: 1.6;
    color: rgba(255, 255, 255, 0.8);
    margin: 0;
  }
  
  .portfolio-body {
    font-size: 16px;
    line-height: 1.8;
    color: rgba(255, 255, 255, 0.9);
  }
  
  .portfolio-body h2 {
    font-family: 'Berkeley Mono', 'Courier New', monospace;
    font-size: 20px;
    font-weight: bold;
    color: #22d3ee;
    margin: 48px 0 16px;
    text-transform: uppercase;
    letter-spacing: 1px;
  }
  
  .portfolio-body h2:first-child {
    margin-top: 0;
  }
  
  .portfolio-body p {
    margin: 0 0 16px;
  }
  
  .portfolio-body ul,
  .portfolio-body ol {
    margin: 0 0 16px;
    padding-left: 24px;
  }
  
  .portfolio-body li {
    margin-bottom: 8px;
  }
  
  .portfolio-body strong {
    color: #22d3ee;
  }
  
  @media (min-width: 768px) {
    .portfolio-title {
      font-size: 36px;
    }
    
    .portfolio-inner {
      padding: 0 48px 120px;
    }
  }
</style>

<script>
  const container = document.getElementById('glitch-container');
  
  function triggerGlitch() {
    if (!container) return;
    
    // Add glitching class
    container.classList.add('glitching');
    
    // Get duration from CSS variable (or default to 200ms)
    const duration = parseInt(getComputedStyle(document.documentElement)
      .getPropertyValue('--glitch-duration')) || 200;
    
    // Remove after duration
    setTimeout(() => {
      container.classList.remove('glitching');
    }, duration);
  }
  
  // Crazy random glitch - each frame is unique
  function triggerCrazyGlitch(duration: number = 800) {
    if (!container) return;
    
    const glitchR = container.querySelector('.glitch-r') as HTMLElement;
    const glitchB = container.querySelector('.glitch-b') as HTMLElement;
    const glitchBase = container.querySelector('.glitch-base') as HTMLElement;
    
    if (!glitchR || !glitchB || !glitchBase) return;
    
    container.classList.add('glitch-crazy');
    
    const startTime = Date.now();
    const intensity = 150;
    
    function randomClipPath() {
      const y1 = Math.random() * 100;
      const height = 5 + Math.random() * 25;
      const y2 = Math.min(y1 + height, 100);
      return `polygon(0 ${y1}%, 100% ${y1}%, 100% ${y2}%, 0 ${y2}%)`;
    }
    
    function tick() {
      const elapsed = Date.now() - startTime;
      if (elapsed >= duration) {
        // Reset everything
        glitchR.style.transform = '';
        glitchR.style.clipPath = '';
        glitchB.style.transform = '';
        glitchB.style.clipPath = '';
        glitchBase.style.transform = '';
        container?.classList.remove('glitch-crazy');
        return;
      }
      
      // Random transforms for R layer
      const rX = (Math.random() - 0.5) * intensity * 2;
      const rY = (Math.random() - 0.5) * intensity;
      glitchR.style.transform = `translate(${rX}px, ${rY}px)`;
      glitchR.style.clipPath = randomClipPath();
      
      // Random transforms for B layer
      const bX = (Math.random() - 0.5) * intensity * 2;
      const bY = (Math.random() - 0.5) * intensity;
      glitchB.style.transform = `translate(${bX}px, ${bY}px)`;
      glitchB.style.clipPath = randomClipPath();
      
      // Random transforms for base
      const baseX = (Math.random() - 0.5) * 40;
      const baseY = (Math.random() - 0.5) * 20;
      const skew = (Math.random() - 0.5) * 8;
      const scale = 0.97 + Math.random() * 0.06;
      glitchBase.style.transform = `translate(${baseX}px, ${baseY}px) skewX(${skew}deg) scale(${scale})`;
      
      // Random interval between 30-80ms for organic feel
      const nextTick = 30 + Math.random() * 50;
      setTimeout(tick, nextTick);
    }
    
    tick();
  }
  
  function triggerFlashWhite() {
    if (!container) return;
    
    // Add flash-white class
    container.classList.add('flash-white');
    
    // Remove after animation completes (600ms)
    setTimeout(() => {
      container.classList.remove('flash-white');
    }, 600);
  }
  
  // SPA-style navigation: fetch portfolio page and inject content without full page load
  // This keeps the WebGL canvas alive during the transition!
  async function loadPortfolioInPlace(slug: string) {
    try {
      // Fetch the portfolio page HTML
      const response = await fetch(`/portfolio/${slug}`);
      const html = await response.text();
      
      // Parse the HTML
      const parser = new DOMParser();
      const doc = parser.parseFromString(html, 'text/html');
      
      // Extract the portfolio content (main element)
      const newMain = doc.querySelector('main.portfolio-page');
      const newStyles = doc.querySelectorAll('style');
      
      if (!newMain) {
        console.error('Could not find portfolio content');
        return;
      }
      
      // Inject the portfolio styles (scoped styles from the page)
      newStyles.forEach(style => {
        // Clone the style element and add to head
        const styleClone = style.cloneNode(true) as HTMLStyleElement;
        styleClone.setAttribute('data-portfolio-style', 'true');
        document.head.appendChild(styleClone);
      });
      
      // Clone and inject the portfolio content
      const mainClone = newMain.cloneNode(true) as HTMLElement;
      
      // Remove any existing transition overlay from cloned content
      const existingOverlay = mainClone.querySelector('#page-transition-overlay');
      if (existingOverlay) existingOverlay.remove();
      
      // Make portfolio content scrollable (since body has overflow: hidden for the GL canvas)
      mainClone.style.cssText = `
        position: fixed;
        inset: 0;
        overflow-y: auto;
        z-index: 1;
      `;
      
      // Add the portfolio content to the body
      document.body.appendChild(mainClone);
      
      // Update the URL without triggering a page load
      history.pushState({ slug }, '', `/portfolio/${slug}`);
      
      // Update the page title
      const newTitle = doc.querySelector('title');
      if (newTitle) {
        document.title = newTitle.textContent || 'Portfolio';
      }
      
      // Trigger the animations (they're CSS-based, so just removing the transition overlay class)
      // The fadeSlideIn animations will play automatically via CSS
      
    } catch (error) {
      console.error('Failed to load portfolio:', error);
      // Fallback to regular navigation
      window.location.href = `/portfolio/${slug}`;
    }
  }
  
  // Handle browser back/forward buttons
  window.addEventListener('popstate', (event) => {
    // If going back to home page
    if (!event.state || !event.state.slug) {
      window.location.href = '/';
    }
  });
  
  if (container) {
    // Trigger glitch on click
    container.addEventListener('click', triggerGlitch);
    
    // Trigger glitch once after page fully loads + 2 seconds
    window.addEventListener('load', () => {
      setTimeout(triggerGlitch, 2000);
      
      // Continue triggering every 12 seconds
      setInterval(triggerGlitch, 12000);
    });
  }
  
  // Custom cursor positioning
  const customCursor = document.getElementById('custom-cursor') as HTMLSpanElement;
  const passwordInputForCursor = document.getElementById('password-input') as HTMLInputElement;
  
  function updateCursorPosition() {
    if (!customCursor || !passwordInputForCursor) return;
    
    // Create a temporary span to measure text width
    const measureSpan = document.createElement('span');
    measureSpan.style.cssText = `
      font-family: 'Berkeley Mono', 'Courier New', monospace;
      font-size: 14px;
      letter-spacing: 2px;
      visibility: hidden;
      position: absolute;
      white-space: pre;
    `;
    // Use bullet characters for password masking (same as browser default)
    measureSpan.textContent = '•'.repeat(passwordInputForCursor.value.length);
    document.body.appendChild(measureSpan);
    
    const textWidth = measureSpan.offsetWidth;
    document.body.removeChild(measureSpan);
    
    // Get the input's padding-left (8px) + prompt width
    const inputRect = passwordInputForCursor.getBoundingClientRect();
    const wrapperRect = passwordInputForCursor.parentElement!.getBoundingClientRect();
    const inputOffsetLeft = inputRect.left - wrapperRect.left;
    
    // Position cursor after the text
    customCursor.style.left = `${inputOffsetLeft + 8 + textWidth}px`;
  }
  
  if (passwordInputForCursor && customCursor) {
    passwordInputForCursor.addEventListener('input', updateCursorPosition);
    passwordInputForCursor.addEventListener('focus', updateCursorPosition);
    // Update on any selection change
    document.addEventListener('selectionchange', () => {
      if (document.activeElement === passwordInputForCursor) {
        updateCursorPosition();
      }
    });
  }
  
  // Password form handler
  const passwordForm = document.getElementById('password-form') as HTMLFormElement;
  const passwordInput = document.getElementById('password-input') as HTMLInputElement;
  const passwordStatus = document.getElementById('password-status') as HTMLDivElement;
  const inputWrapper = document.querySelector('.input-wrapper') as HTMLDivElement;
  
  // Input glitch effect function
  function triggerInputGlitch() {
    if (!inputWrapper) return;
    inputWrapper.classList.add('input-glitching');
    setTimeout(() => {
      inputWrapper.classList.remove('input-glitching');
    }, 450);
  }
  
  if (passwordForm && passwordInput && passwordStatus && inputWrapper) {
    passwordForm.addEventListener('submit', async (e) => {
      e.preventDefault();
      
      const password = passwordInput.value.trim();
      
      if (!password) {
        inputWrapper.classList.add('error');
        passwordStatus.textContent = 'ACCESS CODE REQUIRED';
        passwordStatus.className = 'password-status error';
        triggerInputGlitch();
        setTimeout(() => inputWrapper.classList.remove('error'), 400);
        return;
      }
      
      // Show loading state
      passwordStatus.textContent = 'VALIDATING...';
      passwordStatus.className = 'password-status loading';
      inputWrapper.classList.remove('error', 'success');
      
      try {
        const response = await fetch('/api/validate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ password })
        });
        
        const data = await response.json();
        
        if (data.success) {
          // Success - show message
          inputWrapper.classList.add('success');
          passwordStatus.textContent = 'ACCESS GRANTED';
          passwordStatus.className = 'password-status success';
          
          // Store portfolio info for content loading
          const portfolioSlug = data.slug;
          
          const glitchContainer = document.getElementById('glitch-container') as HTMLElement;
          const passwordContainer = document.querySelector('.password-container') as HTMLElement;
          const appShell = document.querySelector('.app-shell') as HTMLElement;
          const root = document.documentElement;
          
          // Step 1: Flash white effect (glitch -> white -> normal)
          triggerFlashWhite();
          
          // Step 2: After flash completes (600ms) + 400ms wait, trigger CRAZY random glitch
          setTimeout(() => {
            triggerCrazyGlitch(800);
            
            // Step 3: After intense glitch (800ms), fade out both heading and input
            setTimeout(() => {
              if (glitchContainer) {
                glitchContainer.classList.add('fade-out');
              }
              if (passwordContainer) {
                passwordContainer.classList.add('fade-out');
              }
              
              // Step 4: After fade out (400ms), show overlay and redirect
              setTimeout(() => {
                if (appShell) {
                  appShell.remove();
                  window.dispatchEvent(new CustomEvent('headerRemoved'));
                }
                
                // SPA-style navigation: fetch and inject portfolio content
                // This keeps the WebGL canvas alive!
                if (portfolioSlug) {
                  loadPortfolioInPlace(portfolioSlug);
                }
              }, 400);
            }, 800);
          }, 1000); // 600ms flash + 400ms wait
        } else {
          // Invalid password
          inputWrapper.classList.add('error');
          passwordStatus.textContent = 'ACCESS DENIED';
          passwordStatus.className = 'password-status error';
          passwordInput.value = '';
          updateCursorPosition();
          triggerInputGlitch();
          
          setTimeout(() => inputWrapper.classList.remove('error'), 400);
        }
      } catch (error) {
        // Network or server error
        inputWrapper.classList.add('error');
        passwordStatus.textContent = 'SYSTEM ERROR';
        passwordStatus.className = 'password-status error';
        triggerInputGlitch();
        
        setTimeout(() => inputWrapper.classList.remove('error'), 400);
      }
    });
  }
  
  // Visual Viewport API - anchor UI to actual visible area on iOS
  function updateViewportVars() {
    const vv = window.visualViewport;
    if (!vv) return;
    document.documentElement.style.setProperty('--vvh', `${vv.height}px`);
    document.documentElement.style.setProperty('--vvTop', `${vv.offsetTop}px`);
  }
  
  if (window.visualViewport) {
    window.visualViewport.addEventListener('resize', updateViewportVars);
    window.visualViewport.addEventListener('scroll', updateViewportVars);
    updateViewportVars();
  }
</script>
